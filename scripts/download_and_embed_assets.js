#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const https = require('https');
const http = require('http');

const projectRoot = path.join(__dirname, '..');
const assetsDir = path.join(projectRoot, 'assets');
const emotesDir = path.join(assetsDir, 'emotes');
const ratingsDir = path.join(assetsDir, 'ratings');
const iconsDir = path.join(assetsDir, 'icons');
const dataDir = path.join(projectRoot, 'lib', 'data');

// Ensure directories exist
[emotesDir, ratingsDir, iconsDir, dataDir].forEach(dir => {
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
});

// Helper to download a file
function downloadFile(url, destPath) {
  return new Promise((resolve, reject) => {
    const protocol = url.startsWith('https') ? https : http;
    const file = fs.createWriteStream(destPath);

    protocol.get(url, (response) => {
      if (response.statusCode === 301 || response.statusCode === 302) {
        // Handle redirect
        downloadFile(response.headers.location, destPath).then(resolve).catch(reject);
        return;
      }

      if (response.statusCode !== 200) {
        reject(new Error(`Failed to download ${url}: ${response.statusCode}`));
        return;
      }

      response.pipe(file);
      file.on('finish', () => {
        file.close();
        resolve();
      });
    }).on('error', (err) => {
      fs.unlink(destPath, () => {}); // Delete the file on error
      reject(err);
    });
  });
}

// Helper to escape single quotes in strings
function escapeString(str) {
  return str.replace(/'/g, "\\'");
}

// Get filename from URL
function getFilename(url) {
  return path.basename(new URL(url).pathname);
}

// ============================================
// DOWNLOAD AND GENERATE EMOTES
// ============================================
async function processEmotes() {
  const emotesJson = require(path.join(assetsDir, 'emotesList.json'));
  const downloaded = [];
  const failed = [];

  console.log('Downloading emotes...');

  for (const [code, data] of Object.entries(emotesJson)) {
    if (code.includes('LEGEND')) continue;

    const filename = getFilename(data.url);
    const destPath = path.join(emotesDir, filename);

    try {
      if (!fs.existsSync(destPath)) {
        await downloadFile(data.url, destPath);
        console.log(`  Downloaded: ${filename}`);
      }
      downloaded.push({ code, data, filename });

      // Also download dark variant if exists
      if (data.url_dark) {
        const darkFilename = getFilename(data.url_dark);
        const darkDestPath = path.join(emotesDir, darkFilename);
        if (!fs.existsSync(darkDestPath)) {
          await downloadFile(data.url_dark, darkDestPath);
          console.log(`  Downloaded: ${darkFilename}`);
        }
      }
    } catch (err) {
      console.error(`  Failed: ${filename} - ${err.message}`);
      failed.push({ code, error: err.message });
    }
  }

  console.log(`\nEmotes: ${downloaded.length} downloaded, ${failed.length} failed`);

  // Generate Dart file
  generateEmotesDart(downloaded);
}

function generateEmotesDart(emotes) {
  const outputPath = path.join(dataDir, 'emotes.dart');

  let dart = `// Generated by scripts/download_and_embed_assets.js - do not edit manually
// Run: node scripts/download_and_embed_assets.js

class Emote {
  final String code;
  final String assetPath;
  final String? title;
  final String? assetPathDark;
  final bool hidden;

  const Emote({
    required this.code,
    required this.assetPath,
    this.title,
    this.assetPathDark,
    this.hidden = false,
  });
}

const List<Emote> emotes = [
`;

  for (const { code, data, filename } of emotes) {
    const title = data.title ? `'${escapeString(data.title)}'` : 'null';
    const darkFilename = data.url_dark ? getFilename(data.url_dark) : null;
    const assetPathDark = darkFilename ? `'assets/emotes/${darkFilename}'` : 'null';

    dart += `  Emote(
    code: '${escapeString(code)}',
    assetPath: 'assets/emotes/${filename}',
    title: ${title},
    assetPathDark: ${assetPathDark},
    hidden: ${data.hidden ?? false},
  ),
`;
  }

  dart += `];

/// Lookup an emote by code, returns null if not found
Emote? getEmoteByCode(String code) {
  return emotes.where((e) => e.code == code).firstOrNull;
}

/// Get all visible (non-hidden) emotes
List<Emote> get visibleEmotes =>
    emotes.where((e) => !e.hidden).toList();

/// Map of emote codes to emotes for fast lookup
final Map<String, Emote> emoteMap = {
  for (final e in emotes) e.code: e,
};
`;

  fs.writeFileSync(outputPath, dart);
  console.log(`Generated ${emotes.length} emotes to ${outputPath}`);
}

// ============================================
// DOWNLOAD AND GENERATE RATINGS
// ============================================
async function processRatings() {
  const ratingsJson = require(path.join(assetsDir, 'ratingList.json'));
  const downloaded = [];
  const failed = [];

  console.log('\nDownloading ratings...');

  for (const [code, data] of Object.entries(ratingsJson)) {
    const filename = getFilename(data.url);
    const destPath = path.join(ratingsDir, filename);

    try {
      if (!fs.existsSync(destPath)) {
        await downloadFile(data.url, destPath);
        console.log(`  Downloaded: ${filename}`);
      }
      downloaded.push({ code, data, filename });
    } catch (err) {
      console.error(`  Failed: ${filename} - ${err.message}`);
      failed.push({ code, error: err.message });
    }
  }

  console.log(`\nRatings: ${downloaded.length} downloaded, ${failed.length} failed`);

  // Generate Dart file
  generateRatingsDart(downloaded);
}

function generateRatingsDart(ratings) {
  const outputPath = path.join(dataDir, 'ratings.dart');

  let dart = `// Generated by scripts/download_and_embed_assets.js - do not edit manually
// Run: node scripts/download_and_embed_assets.js

class Rating {
  final String code;
  final String name;
  final String assetPath;
  final bool disabled;

  const Rating({
    required this.code,
    required this.name,
    required this.assetPath,
    this.disabled = false,
  });
}

const List<Rating> ratings = [
`;

  for (const { code, data, filename } of ratings) {
    dart += `  Rating(
    code: '${escapeString(code)}',
    name: '${escapeString(data.name)}',
    assetPath: 'assets/ratings/${filename}',
    disabled: ${data.disabled ?? false},
  ),
`;
  }

  dart += `];

/// Lookup a rating by code, returns null if not found
Rating? getRatingByCode(String code) {
  return ratings.where((r) => r.code == code).firstOrNull;
}

/// Get all enabled ratings
List<Rating> get enabledRatings =>
    ratings.where((r) => !r.disabled).toList();

/// Map of rating codes to ratings for fast lookup
final Map<String, Rating> ratingMap = {
  for (final r in ratings) r.code: r,
};
`;

  fs.writeFileSync(outputPath, dart);
  console.log(`Generated ${ratings.length} ratings to ${outputPath}`);
}

// ============================================
// DOWNLOAD AND GENERATE THREAD ICONS
// ============================================
async function processIcons() {
  const iconsJs = fs.readFileSync(path.join(assetsDir, 'icons.js'), 'utf8');
  // Extract the array from the JS file
  const match = iconsJs.match(/const icons = (\[[\s\S]*?\]);/);
  if (!match) {
    console.error('Could not parse icons.js');
    return;
  }

  // Parse the array (it's valid JSON-ish)
  const iconsArray = eval(match[1]);

  const downloaded = [];
  const failed = [];
  const baseUrl = 'https://knockout.chat/';

  console.log('\nDownloading thread icons...');

  for (const icon of iconsArray) {
    const filename = path.basename(icon.url);
    const destPath = path.join(iconsDir, filename);

    // Handle both relative and absolute URLs
    const fullUrl = icon.url.startsWith('http') ? icon.url : baseUrl + icon.url;

    try {
      if (!fs.existsSync(destPath)) {
        await downloadFile(fullUrl, destPath);
        console.log(`  Downloaded: ${filename}`);
      }
      downloaded.push({ ...icon, filename });
    } catch (err) {
      console.error(`  Failed: ${filename} - ${err.message}`);
      failed.push({ id: icon.id, error: err.message });
    }
  }

  console.log(`\nIcons: ${downloaded.length} downloaded, ${failed.length} failed`);

  // Generate Dart file
  generateIconsDart(downloaded);
}

function generateIconsDart(icons) {
  const outputPath = path.join(dataDir, 'thread_icons.dart');

  let dart = `// Generated by scripts/download_and_embed_assets.js - do not edit manually
// Run: node scripts/download_and_embed_assets.js

import 'package:flutter/material.dart';
import 'package:flutter_svg/flutter_svg.dart';

class ThreadIcon {
  final int id;
  final String assetPath;
  final String description;
  final String category;
  final bool restricted;
  final bool disabled;
  final Color? bg;

  const ThreadIcon({
    required this.id,
    required this.assetPath,
    required this.description,
    required this.category,
    this.restricted = false,
    this.disabled = false,
    this.bg,
  });

  /// Check if this icon is an SVG file
  bool get isSvg => assetPath.toLowerCase().endsWith('.svg');

  /// Build a widget for this icon
  Widget buildIcon({
    double? width,
    double? height,
    BoxFit fit = BoxFit.contain,
  }) {
    if (isSvg) {
      return SvgPicture.asset(
        assetPath,
        width: width,
        height: height,
        fit: fit,
        placeholderBuilder: (_) => SizedBox(width: width, height: height),
      );
    }
    return Image.asset(
      assetPath,
      width: width,
      height: height,
      fit: fit,
      errorBuilder: (_, _, _) => SizedBox(width: width, height: height),
    );
  }
}

const List<ThreadIcon> threadIcons = [
`;

  for (const icon of icons) {
    const bg = icon.bg ? `Color(0xFF${icon.bg.replace('#', '')})` : 'null';
    dart += `  ThreadIcon(
    id: ${icon.id},
    assetPath: 'assets/icons/${icon.filename}',
    description: '${escapeString(icon.description)}',
    category: '${escapeString(icon.category)}',
    restricted: ${icon.restricted ?? false},
    disabled: ${icon.disabled ?? false},
    bg: ${bg},
  ),
`;
  }

  dart += `];

/// Lookup a thread icon by ID, returns default icon if not found
ThreadIcon getThreadIconById(int id) {
  return threadIcons.firstWhere(
    (icon) => icon.id == id,
    orElse: () => threadIcons.first,
  );
}

/// Get all enabled (non-disabled) icons
List<ThreadIcon> get enabledIcons =>
    threadIcons.where((i) => !i.disabled).toList();

/// Get all non-restricted icons
List<ThreadIcon> get publicIcons =>
    threadIcons.where((i) => !i.restricted && !i.disabled).toList();

/// Map of icon IDs to icons for fast lookup
final Map<int, ThreadIcon> iconMap = {
  for (final i in threadIcons) i.id: i,
};
`;

  fs.writeFileSync(outputPath, dart);
  console.log(`Generated ${icons.length} thread icons to ${outputPath}`);
}

// ============================================
// UPDATE PUBSPEC.YAML ASSETS
// ============================================
function updatePubspec() {
  const pubspecPath = path.join(projectRoot, 'pubspec.yaml');
  let pubspec = fs.readFileSync(pubspecPath, 'utf8');

  // Check if all assets are already declared
  const hasEmotes = pubspec.includes('assets/emotes/');
  const hasRatings = pubspec.includes('assets/ratings/');
  const hasIcons = pubspec.includes('assets/icons/');

  if (hasEmotes && hasRatings && hasIcons) {
    console.log('\nAssets already declared in pubspec.yaml');
    return;
  }

  // Add missing asset declarations
  if (pubspec.includes('assets:')) {
    if (!hasEmotes) {
      pubspec = pubspec.replace(/assets:\n/, 'assets:\n    - assets/emotes/\n');
    }
    if (!hasRatings) {
      pubspec = pubspec.replace(/assets:\n/, 'assets:\n    - assets/ratings/\n');
    }
    if (!hasIcons) {
      pubspec = pubspec.replace(/assets:\n/, 'assets:\n    - assets/icons/\n');
    }
  } else {
    // Add new assets section after uses-material-design
    const assetsSection = `
  assets:
    - assets/emotes/
    - assets/ratings/
    - assets/icons/
`;
    pubspec = pubspec.replace(
      /(uses-material-design: true)/,
      `$1\n${assetsSection}`
    );
  }

  fs.writeFileSync(pubspecPath, pubspec);
  console.log('\nUpdated pubspec.yaml with asset declarations');
}

// ============================================
// MAIN
// ============================================
async function main() {
  console.log('Downloading and embedding assets...\n');

  try {
    await processEmotes();
    await processRatings();
    await processIcons();
    updatePubspec();

    console.log('\nDone! Run `flutter pub get` to refresh assets.');
  } catch (err) {
    console.error('Error:', err.message);
    process.exit(1);
  }
}

main();
